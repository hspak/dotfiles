#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

#define TRUE 1
#define FALSE 0
#define MAX_ADJ 8 /* each node can have a max of 8 nodes in its adj list */

#define ID 1
#define D 0

struct list {
        int id;
        int d;
        int has_log;
        struct list *pred;
        struct list *next;
};

/* {{{ Declarations */
static void* my_malloc(size_t sz);
/*}}}*/

/* {{{ List */
struct list* create_list(int id, int log)
{
        struct list *node = my_malloc(sizeof(struct list));
        node->id = id;
        node->d = INT_MAX;
        node->has_log = log;
        node->next = NULL;
        node->pred = NULL;
        return node;
}                       

void add_adj_node(struct list *head, int id, int log)
{
        struct list *node = create_list(id, log);
        if (head) {
                while (head->next)
                        head = head->next;
                head->next = node;
        }
}

void destroy_list(struct list *head)
{
        struct list *prev = NULL;
        struct list *curr = NULL;
        if (head) {
                curr = head->next;
                while (curr) {
                        prev = curr;
                        curr = curr->next;
                        free(prev);
                }
                free(head);
        }
}
/* }}} */

/* {{{ Args */
int valid_args(int argc, char *argv[])
{
        int valid = TRUE;
        if (argc < 2) {
                fprintf(stderr, "usage: ./proj5 <input file>\n");
                valid = FALSE;
        }
        return valid;
}

FILE* valid_file(char *fn)
{
        FILE *fp = fopen(fn, "r");
        if (fp == NULL) {
                fprintf(stderr, "error: could not open file\n");
        }
        return fp;
} /*}}}*/

/* {{{ Misc */
void* my_malloc(size_t sz)
{
        void *mem = malloc(sz);
        if (!mem) {
                fprintf(stderr, "error: could not allocate memory\n");
                exit(1);
        }
        return mem;
}

int asc_to_int(char c)
{
        return c - '0';
}

void p_a(char *a, int len)
{
        int i;
        for (i = 0; i < len; i++)
                printf("%c\n", a[i]);
}

void print_matrix(char **graph, int len)
{
        int col = len/2;
        int row = col-1;
        int i, j;
        for (i = 0; i < row; i++) {
                for (j = 0; j < col; j++) {
                        printf("%c ", graph[i][j]);
                }
                printf("\n");
        }
}

void print_adj(struct list *node)
{
        while (node) {
                printf("%d -> ", node->id);
                node=node->next;
        }
        printf("\n");
} /* }}} */

/* {{{ Parsing */
int get_col_cnt(FILE *fp)
{
        int sz;
        fscanf(fp, "%d", &sz);
        return sz;
}

char* parse_file(FILE *fp, int *len)
{
        char *pathing = NULL;
        *len = get_col_cnt(fp);
        *len = (*len) * ((*len)-1);
        pathing = my_malloc(sizeof(char) * (*len));

        int ch;
        int i = 0;
        /* ignore the column number */
        while ((ch = fgetc(fp)) != '\n') {
                continue;
        }
        while ((ch = fgetc(fp)) != EOF) {
                if (ch != '\n')
                        pathing[i++] = ch;
        }
        return pathing;
}
/* }}} */
         
/* {{{ Heap */
void up_heap(int *arr, int n)
{
        int new = arr[n];
        int child = n;
        int par = (child-1)/2;
        /* while (child > 0 && arr[par] < new) { */
        while (child > 0 && arr[par] >= new) {
                arr[child] = arr[par];
                child = par;
                par = (child-1)/2;
        }
        arr[child] = new;
}

void down_heap(int *arr, int i, int n)
{
        int j;
        int tmp = arr[i];
        while ((j = (2*i+1)) <= n) {
                /* if (j < n && arr[j] < arr[j+1]) */
                if (j < n && arr[j] > arr[j+1])
                        j++;
                /* if (tmp >= arr[j]) { */
                if (tmp < arr[j]) {
                        break;
                } else {
                        arr[i] = arr[j];
                        i = j;
                }
        }
        arr[i] = tmp;
}
                         
void enqueue(int (*arr)[2], int max, int *len, int data, int id)
{
        printf("-> %d\n", data);
        if (*len < max) {
                arr[*len][D] = data;
                arr[*len][ID] = id;
                up_heap(arr[D], *len);
                (*len)++;
        } else {
                fprintf(stderr, "error: queue overflow\n");
        }
}

int dequeue(int (*arr)[2], int *len)
{
        int deq = arr[0][ID];
        printf("<- %d\n", arr[0][D]);
        if (*len > 0) {
                arr[0][D] = arr[*len-1][D];
                down_heap(arr[D], 0, *len-1);
                (*len)--;
                return deq;
        } else {
                fprintf(stderr, "error: queue underflow\n");
        }
        return -1;
}
/* }}} */
 
/* {{{ Graph */
void create_adj_list(struct list *node, char *pathing, int id, 
                                        int rc, int cc, int col, int row)
{
        if ((rc-1) >= 0 && (cc-1) >= 0)
                add_adj_node(node, id-(col+1), pathing[id] - '0');
        if ((rc-1) >= 0)
                add_adj_node(node, id-col, pathing[id] - '0');
        if ((rc-1) >= 0 && (cc+1) < col)
                add_adj_node(node, id-(col-1), pathing[id] - '0');
        if ((cc-1) >= 0)
                add_adj_node(node, id-1, pathing[id] - '0');
        if ((cc+1) < col)
                add_adj_node(node, id+1, pathing[id] - '0');
        if ((rc+1) < row && (cc-1) >= 0)
                add_adj_node(node, id+(col-1), pathing[id] - '0');
        if ((rc+1) < row)
                add_adj_node(node, id+col, pathing[id] - '0');
        if ((rc+1) < row && (cc+1) < col)
                add_adj_node(node, id+(col+1), pathing[id] - '0');
}

struct list** create_graph(char *pathing, int len)
{
        int col = len/2;
        int row = col-1;
        int cc = 0, rc = 0;
        struct list **graph = my_malloc(sizeof(struct list) * len);
        int i, j = 0;
        for (i = 0; i < len; i++) {
                if (asc_to_int(pathing[i]) == 1)
                        graph[j++] = create_list(i, pathing[i] - '0');
                /*create_adj_list(graph[i], pathing, i, rc, cc, col, row);*/
                cc++;
                if (cc == col) {
                        cc = 0;
                        rc++;
                }
        }
        return graph;
}

void destroy_graph(struct list **graph, int len)
{
        int i;
        for (i = 0; i < len; i++) {
                destroy_list(graph[i]);
        }
        free(graph);
}

int get_edge_wgt(struct list *src, struct list *dest)
{
        if (dest->has_log)
                return 1;
        else
                return 2;
}

void shortest_path(struct list **graph, int s, int len)
{
        struct list *node = NULL;
        struct list *adj = NULL;
        int (*pq)[2] = malloc(sizeof(int) * len);
        int pq_len = 0;
        graph[s]->d = 0;
        enqueue(pq, len, &pq_len, graph[s]->d, s);

        int min_id = 0;
        int min_d = 0;
        int d_u = 0;
        while (pq_len > 0) {
                node = graph[dequeue(pq, &pq_len)];
                min_id = -1;
                min_d = INT_MAX;
                adj = node->next;
                d_u = adj->d = get_edge_wgt(node, adj);
                while (adj) {
                        adj->d = get_edge_wgt(node, adj);
                        if (adj->d < min_d) {
                                min_d = adj->d;
                                min_id = adj->id;
                        }
                        printf("%d\n", min_id);
                        adj = adj->next;
                }
                enqueue(pq, len, &pq_len, min_d, min_id);
        }
}
/* }}} */

int main(int argc, char *argv[])
{
        FILE *fp = NULL;
        if (!valid_args(argc, argv) || !(fp = valid_file(argv[1]))) {
                return EXIT_FAILURE;
        }

        int len;
        char *pathing = parse_file(fp, &len);
        struct list **graph = create_graph(pathing, len);
        free(pathing);

        print_adj(graph[0]);
        print_adj(graph[1]);
        print_adj(graph[2]);
        print_adj(graph[3]);
        print_adj(graph[4]);
        print_adj(graph[5]);
        shortest_path(graph, 0, len);

        /* cleanup */
        destroy_graph(graph, len);
        fclose(fp);
        return EXIT_SUCCESS;
}

